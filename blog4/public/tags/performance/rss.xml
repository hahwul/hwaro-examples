<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>DevLog - Tags: performance</title>
    <link>http://localhost:3000</link>
    <description>Today I Learned &amp; Changelog</description>
    <atom:link href="http://localhost:3000/tags/performance/rss.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Debugging Memory Leaks in Long-Running Processes</title>
      <link>http://localhost:3000/log/debugging-memory-leaks/</link>
      <guid>http://localhost:3000/log/debugging-memory-leaks/</guid>
      <description>&lt;p&gt;Last week we hit a memory leak in production — the process grew from 200MB to 4GB over 48 hours. Here&apos;s how we tracked it down.&lt;/p&gt;
&lt;h2 id=&quot;symptoms&quot;&gt;Symptoms&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;RSS memory climbed steadily with no plateau&lt;/li&gt;
&lt;li&gt;GC runs became more frequent but didn&apos;t reclaim memory&lt;/li&gt;
&lt;li&gt;No obvious large allocations in the code&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;investigation&quot;&gt;Investigation&lt;/h2&gt;
&lt;h3 id=&quot;step-1-heap-snapshots&quot;&gt;Step 1: Heap snapshots&lt;/h3&gt;
&lt;p&gt;We added a debug endpoint to dump heap statistics:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-crystal hljs&quot;&gt;get &amp;quot;/debug/heap&amp;quot; do
  stats = GC.stats
  {
    heap_size:  stats.heap_size,
    free_bytes: stats.free_bytes,
    total_bytes: stats.total_bytes,
  }.to_json
end
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;step-2-bisect-by-time&quot;&gt;Step 2: Bisect by time&lt;/h3&gt;
&lt;p&gt;By comparing snapshots, we found that &lt;code&gt;String&lt;/code&gt; allocations were growing unbounded. The culprit was a logging buffer that was never flushed:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-crystal hljs&quot;&gt;# BUG: buffer grows forever
class Logger
  @buffer = [] of String

  def log(msg : String)
    @buffer &amp;lt;&amp;lt; &amp;quot;[#{Time.utc}] #{msg}&amp;quot;
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;step-3-the-fix&quot;&gt;Step 3: The fix&lt;/h3&gt;
&lt;p&gt;We added a ring buffer with a fixed capacity:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-crystal hljs&quot;&gt;class Logger
  CAPACITY = 10_000
  @buffer = Deque(String).new

  def log(msg : String)
    @buffer.shift if @buffer.size &amp;gt;= CAPACITY
    @buffer &amp;lt;&amp;lt; &amp;quot;[#{Time.utc}] #{msg}&amp;quot;
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;{{&amp;lt; alert type=&amp;quot;tip&amp;quot; message=&amp;quot;Always set upper bounds on in-memory buffers. Unbounded collections are a common source of leaks.&amp;quot; &amp;gt;}}&lt;/p&gt;
&lt;h2 id=&quot;lessons-learned&quot;&gt;Lessons learned&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Monitor RSS, not just GC stats&lt;/strong&gt; — GC may report low usage while the OS sees high RSS&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Add debug endpoints&lt;/strong&gt; — they cost almost nothing and save hours during incidents&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Set limits on all buffers&lt;/strong&gt; — if it can grow, it will grow&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;The best time to add memory monitoring is before you need it.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
      <pubDate>Sat, 7 Jun 2025 15:00:00 +0000</pubDate>
    </item>
  </channel>
</rss>
